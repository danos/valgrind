Description: Instrument pthread_cond_init() in helgrind
Origin: upstream, r13332
Bug: https://bugs.kde.org/show_bug.cgi?id=307082
Bug-Debian: http://bugs.debian.org/723699
Author: Philippe Waroquiers
Reviewed-by: Alessandro Ghedini <ghedo@debian.org>
Last-Update: 2013-09-24

--- a/helgrind/helgrind.h
+++ b/helgrind/helgrind.h
@@ -115,7 +115,8 @@
       _VG_USERREQ__HG_ARANGE_MAKE_UNTRACKED, /* Addr a, ulong len */
       _VG_USERREQ__HG_ARANGE_MAKE_TRACKED,   /* Addr a, ulong len */
       _VG_USERREQ__HG_PTHREAD_BARRIER_RESIZE_PRE, /* pth_bar_t*, ulong */
-      _VG_USERREQ__HG_CLEAN_MEMORY_HEAPBLOCK  /* Addr start_of_block */
+      _VG_USERREQ__HG_CLEAN_MEMORY_HEAPBLOCK, /* Addr start_of_block */
+      _VG_USERREQ__HG_PTHREAD_COND_INIT_POST  /* pth_cond_t*, pth_cond_attr_t*/
 
    } Vg_TCheckClientRequest;
 
--- a/helgrind/hg_main.c
+++ b/helgrind/hg_main.c
@@ -2374,6 +2374,22 @@
    cvi->nWaiters--;
 }
 
+static void evh__HG_PTHREAD_COND_INIT_POST ( ThreadId tid,
+                                             void* cond, void* cond_attr )
+{
+   CVInfo* cvi;
+
+   if (SHOW_EVENTS >= 1)
+      VG_(printf)("evh__HG_PTHREAD_COND_INIT_POST"
+                  "(ctid=%d, cond=%p, cond_attr=%p)\n", 
+                  (Int)tid, (void*)cond, (void*) cond_attr );
+
+   cvi = map_cond_to_CVInfo_lookup_or_alloc( cond );
+   tl_assert (cvi);
+   tl_assert (cvi->so);
+}
+
+
 static void evh__HG_PTHREAD_COND_DESTROY_PRE ( ThreadId tid,
                                                void* cond )
 {
@@ -4736,6 +4752,13 @@
          break;
       }
 
+      /* Thread successfully completed pthread_cond_init:
+         cond=arg[1], cond_attr=arg[2] */
+      case _VG_USERREQ__HG_PTHREAD_COND_INIT_POST:
+         evh__HG_PTHREAD_COND_INIT_POST( tid,
+                                         (void*)args[1], (void*)args[2] );
+	 break;
+
       /* cond=arg[1] */
       case _VG_USERREQ__HG_PTHREAD_COND_DESTROY_PRE:
          evh__HG_PTHREAD_COND_DESTROY_PRE( tid, (void*)args[1] );
--- a/helgrind/tests/Makefile.am
+++ b/helgrind/tests/Makefile.am
@@ -12,6 +12,7 @@
 		annotate_rwlock.stderr.exp \
 	annotate_smart_pointer.vgtest annotate_smart_pointer.stdout.exp \
 		annotate_smart_pointer.stderr.exp \
+	cond_init_destroy.vgtest cond_init_destroy.stderr.exp \
 	cond_timedwait_invalid.vgtest cond_timedwait_invalid.stdout.exp \
 		cond_timedwait_invalid.stderr.exp \
 	bar_bad.vgtest bar_bad.stdout.exp bar_bad.stderr.exp \
@@ -97,6 +98,7 @@
 # should be conditionally compiled like tc20_verifywrap is.
 check_PROGRAMS = \
 	annotate_hbefore \
+	cond_init_destroy \
 	cond_timedwait_invalid \
 	free_is_write \
 	hg01_all_ok \
--- /dev/null
+++ b/helgrind/tests/cond_init_destroy.c
@@ -0,0 +1,8 @@
+#include <pthread.h>
+int main(int argc, char *argv[])
+{
+   pthread_cond_t c;
+   pthread_cond_init(& c, NULL);
+   pthread_cond_destroy(& c);
+   return 0;
+} 
--- /dev/null
+++ b/helgrind/tests/cond_init_destroy.stderr.exp
@@ -0,0 +1,3 @@
+
+
+ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
--- /dev/null
+++ b/helgrind/tests/cond_init_destroy.vgtest
@@ -0,0 +1 @@
+prog: cond_init_destroy
--- a/helgrind/hg_intercepts.c
+++ b/helgrind/hg_intercepts.c
@@ -631,10 +631,8 @@
 
 /* Handled:   pthread_cond_wait pthread_cond_timedwait
               pthread_cond_signal pthread_cond_broadcast
+              pthread_cond_init
               pthread_cond_destroy
-
-   Unhandled: pthread_cond_init
-              -- is this important?
 */
 
 //-----------------------------------------------------------
@@ -917,6 +915,55 @@
 #   error "Unsupported OS"
 #endif
 
+// glibc:  pthread_cond_init@GLIBC_2.0
+// glibc:  pthread_cond_init@GLIBC_2.2.5
+// glibc:  pthread_cond_init@@GLIBC_2.3.2
+// darwin: pthread_cond_init
+// Easy way out: Handling of attr could have been messier.
+// It turns out that pthread_cond_init under linux ignores
+// all information in cond_attr, so do we.
+// FIXME: MacOS X?
+__attribute__((noinline))
+static int pthread_cond_init_WRK(pthread_cond_t* cond, pthread_condattr_t *cond_attr)
+{
+   int ret;
+   OrigFn fn;
+   VALGRIND_GET_ORIG_FN(fn);
+
+   if (TRACE_PTH_FNS) {
+      fprintf(stderr, "<< pthread_cond_init %p", cond);
+      fflush(stderr);
+   }
+
+   CALL_FN_W_WW(ret, fn, cond, cond_attr);
+
+   if (ret == 0) {
+      DO_CREQ_v_WW(_VG_USERREQ__HG_PTHREAD_COND_INIT_POST,
+                   pthread_cond_t*,cond, pthread_condattr_t*, cond_attr);
+   } else {
+      DO_PthAPIerror( "pthread_cond_init", ret );
+   }
+
+   if (TRACE_PTH_FNS) {
+      fprintf(stderr, " coinit -> %d >>\n", ret);
+   }
+
+   return ret;
+}
+#if defined(VGO_linux)
+   PTH_FUNC(int, pthreadZucondZuinitZAZa, // pthread_cond_init@*
+	    pthread_cond_t* cond, pthread_condattr_t* cond_attr) {
+     return pthread_cond_init_WRK(cond, cond_attr);
+   }
+#elif defined(VGO_darwin)
+   PTH_FUNC(int, pthreadZucondZuinit, // pthread_cond_init
+	    pthread_cond_t* cond, pthread_condattr_t * cond_attr) {
+     return pthread_cond_init_WRK(cond, cond_attr);
+   }
+#else
+#  error "Unsupported OS"
+#endif
+
 
 //-----------------------------------------------------------
 // glibc:  pthread_cond_destroy@@GLIBC_2.3.2
